# -*- coding: utf-8 -*-
"""Portfolio Optimization Using Convex Optimization (Wrapped Function) UPDATED.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wicNTzqPQN5ngh0jG922yEUIeBd2qJpV
"""
#%%
# Need to import datetime outside this wrapper function
import datetime

def Portfolio_Optimization(portfolio_tickers, start_date = (datetime.datetime.now() - datetime.timedelta(days=365)).date(),
                           risk_free_rate = 1.1, max_risk = None, annual_expected_return = None, risk_free_asset = False,
                          disable_chart_tickers = False):
    
    # Initialize Libraries
    import numpy as np
    import pandas as pd
    import quadprog
    import matplotlib.pyplot as plt
    import copy
    import datetime
    from pandas_datareader import data
    from sklearn.linear_model import LinearRegression
    np.set_printoptions(precision=5, suppress=True)
    pd.set_option('display.float_format', lambda x: f'{x:,.5f}')
    
    # Helper Sharpe Ratio Function
    def Sharpe_Ratio(portfolio_tickers, start_date, close, adj_close, risk_free_rate, weights, risk_free_asset = False):
        # Initialize Statements
        output_str = ""
        
        if risk_free_asset == True:
            RFA_weight = weights[-1]
            weights = weights[:-1]

        # Calculate the Sharpe Ratio
        risk_free_ann_ret_rate = risk_free_rate/100 

        returns_ts = adj_close.pct_change().dropna()
        avg_daily_ret = returns_ts.mean()

        # Create the risk free rate column
        returns_ts['RiskFree_Rate'] = risk_free_ann_ret_rate/252
        avg_rf_ret = returns_ts['RiskFree_Rate'].mean()

        # Calculate sharpe ratio
        # Add the excess return columns for each ETF
        portfolio_tickers_dict = dict(enumerate(portfolio_tickers))
        sharpe_ratio_df = pd.DataFrame()

        for i in range(len(portfolio_tickers)):
            returns_ts['Excess_ret_'+portfolio_tickers_dict[i]] = returns_ts[portfolio_tickers_dict[i]] - returns_ts['RiskFree_Rate']
            sharpe_ratio = pd.Series(((avg_daily_ret[portfolio_tickers_dict[i]] - avg_rf_ret) /
                                      returns_ts['Excess_ret_'+portfolio_tickers_dict[i]].std())*np.sqrt(252))
            sharpe_ratio_df = sharpe_ratio_df.append(sharpe_ratio, ignore_index = True)
        sharpe_ratio_df.rename(portfolio_tickers_dict, axis = 'index', inplace = True)
        sharpe_ratio_df.rename({0:'Sharpe Ratio'}, axis = 'columns', inplace = True)

        # Portfolio returns (Sharpe Ratio)
        return_series_adj = (adj_close.pct_change()+ 1).cumprod() - 1
        return_series_close = (close.pct_change()+ 1).cumprod() - 1

        # Sum the weighted returns of the selected Portfolio
        weighted_return_series_adj = weights * (return_series_adj)
        return_series_adj = weighted_return_series_adj.sum(axis=1)
        weighted_return_series_close = weights * (return_series_close)
        return_series_close = weighted_return_series_close.sum(axis=1)

        ret_since_start = return_series_adj.tail(1)

        if risk_free_asset == True:
            ret_since_start += ((risk_free_rate/100)/252) * ((datetime.date.today() - start_date).days*(252/365))

        output_str += f"Portfolio Return since {start_date}: " + str(ret_since_start[-1].round(3)) + "  \n  "

        ann_vol = np.sqrt(252) * np.log((return_series_close+1)/(return_series_close+1).shift(1)).std()
        output_str += "Portfolio Annualized Volatility: " + str(ann_vol.round(3)) + "  \n  "

        # Multiply the daily pct.change() with the weights
        weighted_returns = weights * (returns_ts[portfolio_tickers])
        returns = pd.DataFrame(weighted_returns.sum(axis = 1), columns= ['Portfolio'])
        if risk_free_asset == True:
            returns += RFA_weight * ((risk_free_rate/100)/252)

        #find the average daily return
        avg_daily = returns.mean()
        output_str += 'Average daily return of Portfolio: ' +  str(avg_daily['Portfolio']) + '  \n  '

        # Create a risk free annual rate column in the DF.
        # the annual rf rate must be divided by 252 to spread it across the year
        returns['RiskFree_Rate'] = risk_free_ann_ret_rate / 252

        # Find the average rf rate
        avg_rf_ret = returns['RiskFree_Rate'].mean()
        output_str += 'Average risk free rate: ' +  str('{:.7f}'.format(avg_rf_ret)) + '  \n  '

        # Create the excess returns column
        returns['Excess_ret'] = returns['Portfolio'] - returns['RiskFree_Rate']
        # Use the sharpe ratio formula to find RAR
        sharpe_ratio = ((avg_daily - avg_rf_ret) / returns['Excess_ret'].std())*np.sqrt(252)
        if sharpe_ratio[0] < 1:
            output_str += 'WARNING: Sharpe Ratio of the Portfolio is less than 1.  \n  '
        output_str += 'Sharpe Ratio for the Portfolio: ' + str(sharpe_ratio[0].round(3)) + '  \n  '
        return output_str
    
    # Initialize Statements
    output_str = ""
    
    # Initialize Logic Check
    use_TP = False
    
    # Data Import
    n = len(portfolio_tickers)
    portfolio_tickers_dict = dict(enumerate(portfolio_tickers))
    if risk_free_asset == True:
        rfa_portfolio_tickers_dict = dict(enumerate(portfolio_tickers + ['Risk Free Asset']))
    end_date = datetime.datetime.now()

    # User pandas_reader.data.DataReader to load data
    panel_data = data.DataReader(portfolio_tickers,'yahoo', start_date, end_date)
    # save the close and Adj Close prices
    adj_close = panel_data['Adj Close']
    close = panel_data['Close']
    
    # Calculate returns
    ret = np.log(adj_close).diff()
    ret.dropna(inplace=True)
    
    # Convert returns to percentage
    R = 100*ret
    
    # Calculate relevent statistics
    mean = R.apply(np.mean)
    cov = R.cov()
    sd = np.sqrt(np.diag(cov))
    
    # Variables
    Amat = pd.concat([mean, pd.Series(np.ones(n), index=list(mean.index))], axis=1, ignore_index=True)
    Amat = np.array(Amat)
    Amat[:, [1, 0]] = Amat[:, [0, 1]]
    Amat = np.hstack([Amat,np.diag([1]*n)])
    muP = np.linspace(min(mean)+0.0001, max(mean)-0.0001, int((max(mean)-min(mean))/0.000375))
    sdP = copy.deepcopy(muP)
    wts = np.zeros((int((max(mean)-min(mean))/0.000375),n))
    meq = 2
    
    
    # Compute efficient portfolio weights for each target
    for i in range(len(muP)):
        bvec = np.hstack([1, muP[i], np.zeros(n)])
        result = quadprog.solve_qp(np.array(2*cov), np.zeros(n), Amat, bvec, meq)
        sdP[i] = np.sqrt(result[1])
        wts[i] = result[0]
        
    # rfr is the risk free rate(percent per day)
    rfr = risk_free_rate/252
    SR = (muP-rfr)/sdP
    ind=(SR==max(SR))
    
    # Calculate weights of the tangentcy portfolio
    TP_weights = wts[ind]
    TP_expectedreturn = muP[ind]
    TP_stddev = sdP[ind]
    
    weights_TP = []
    for item in list(TP_weights.reshape(n,)):
        if abs(item) < 0.000001:
            weights_TP += [0]
        else:
            weights_TP += [round(item,4)]
    
    # Format the DataFrame and Rename Columns of the TP DataFrame
    TP = pd.DataFrame(weights_TP)
    TP.rename({0:'Weights'}, axis='columns', inplace=True)
    TP.rename(portfolio_tickers_dict, axis='rows', inplace=True)

    # Show global minimum variance portfolio and plot efficient frontier
    ind2 = (sdP == min(sdP))
    GMVP_weights = wts[ind2]
    GMVP_expectedreturn = muP[ind2]
    GMVP_stddev = sdP[ind2]
    
    weights_GMVP = []
    for item in list(GMVP_weights.reshape(n,)):
        if abs(item) < 0.000001:
            weights_GMVP += [0]
        else:
            weights_GMVP += [round(item,4)]
            
    # Security Market Line
    SML_x = np.append(np.array([0]), TP_stddev+(max(sdP)/2)).reshape(-1, 1)
    SML_y = np.append(np.array([rfr*(muP[ind]-rfr)/sdP[ind]]),
                      (rfr+TP_stddev+(max(sdP)/2))*(muP[ind]-rfr)/sdP[ind]).reshape(-1, 1)
    linear_regression = LinearRegression()
    linear_regression.fit(SML_y, SML_x)
    
    # If there is an expected return, find a portfolio that has the lowest variance for it
    if annual_expected_return != None:
        ER = annual_expected_return/252
        if ER < TP_expectedreturn and risk_free_asset == True:
            sdP_ER5 = (ER-rfr)/max(SR)
            TP_ratio = sdP_ER5/sdP[ind]
            TP_ratio[0]
            RFA_ratio = 1 - TP_ratio
            RFA_ratio[0]
            RFAP_weights = np.hstack([(TP_ratio * wts[ind]).reshape([n,]), RFA_ratio])
            RFAP_expectedreturn = [ER]
            RFAP_stddev = linear_regression.predict([RFAP_expectedreturn])[0]

            weights_RFAP = []
            for item in list(RFAP_weights.reshape(n+1,)):
                if abs(item) < 0.000001:
                    weights_RFAP += [0]
                else:
                    weights_RFAP += [round(item,4)]

            RFAP = pd.DataFrame(weights_RFAP)
            RFAP.rename({0:'Weights'}, axis='columns', inplace=True)
            RFAP.rename(rfa_portfolio_tickers_dict, axis='rows', inplace=True)
        elif risk_free_asset == False:
            # To compute the portfolios without risk-free asset, we find the index at which muP = ER and we subset the indexes into wts.
            ind5 = np.bitwise_and((ER - 0.0001875) < muP, muP < (ER + 0.0001875))
            noRFAP_weights = wts[ind5]
            noRFAP_expectedreturn = muP[ind5]
            noRFAP_stddev = sdP[ind5]

            weights_noRFAP = []
            for item in list(noRFAP_weights.reshape(n,)):
                if abs(item) < 0.000001:
                    weights_noRFAP += [0]
                else:
                    weights_noRFAP += [round(item,4)]

            noRFAP = pd.DataFrame(weights_noRFAP)
            noRFAP.rename({0:'Weights'}, axis='columns', inplace=True)
            noRFAP.rename(portfolio_tickers_dict, axis='rows', inplace=True)
        else:
            use_TP = True
            
        
    # Format the DataFrame and Rename Columns of the GMVP DataFrame
    GMVP = pd.DataFrame(weights_GMVP)
    GMVP.rename({0:'Weights'}, axis='columns', inplace=True)
    GMVP.rename(portfolio_tickers_dict, axis='rows', inplace=True)

    ind3 = (muP > muP[ind2])
    ind4 = np.invert(ind3)
    

    # Identify the top three assets
    fig = plt.figure(figsize=(9,4))
    plt.plot(SML_x, SML_y, color='darkblue')
    plt.plot(sdP[ind3], muP[ind3], color='red')
    plt.plot(sdP[ind4], muP[ind4], color='green')
    plt.plot(0, rfr, 'r*')
    plt.text(0.1, rfr, 'Risk-free rate')
    plt.plot(TP_stddev, TP_expectedreturn, 'k*')
    plt.text(TP_stddev-0.5, TP_expectedreturn, 'Tangency-Portfolio')
    plt.plot(GMVP_stddev, GMVP_expectedreturn, 'k+')
    plt.text(GMVP_stddev-0.5, GMVP_expectedreturn, 'GMVP')
    if annual_expected_return != None and use_TP == False:
        if risk_free_asset == True:
            plt.plot(RFAP_stddev[0], RFAP_expectedreturn[0], 'k*')
            plt.text(RFAP_stddev[0]-0.5, RFAP_expectedreturn[0], 'Optimal Portfolio w/ RFA')
        elif noRFAP_expectedreturn > GMVP_expectedreturn:
            plt.plot(noRFAP_stddev, noRFAP_expectedreturn, 'k*')
            plt.text(noRFAP_stddev-0.15, noRFAP_expectedreturn, 'Optimal Portfolio w/o RFA')
    for i in range(n):
        if disable_chart_tickers == True:
            break
        plt.plot(sd[i], mean[i], 'ko')
        plt.text(sd[i]+0.1, mean[i]-0.01, portfolio_tickers_dict[i])
    plt.xlabel('Expected Risk')
    plt.ylabel('Expected Returns')
    plt.legend(['Security Market Line','Efficient portfolio','Inefficient portfolio'], loc='upper left')
    
    if max_risk != None:
        if max_risk < GMVP_stddev and risk_free_asset == False:
            output_str += "WARNING: Max risk allowed is lower than the risk of the Global Minimum Variance Portfolio.  \n  "
        if risk_free_asset == True:
            if max_risk < RFAP_stddev:
                output_str += "WARNING: Max risk allowed is lower than the risk of the Optimal Portfolio with Risk Free Asset.  \n  "
    
    if annual_expected_return == None:
        if max_risk == None or max_risk >= TP_stddev:
            output_str += "The Tangency Portfolio's daily Expected Returns (logged first difference) are: " + str(TP_expectedreturn[0].round(7)) + '  \n  '
            output_str += "The Standard Deviation (of the logged first difference returns) of the Tangency Portfolio is " + str(TP_stddev[0].round(7)) + '  \n  '
            output_str += "The Tangency Portfolio's annualized Expected Returns (logged first difference) are: " + str((TP_expectedreturn[0] * 252).round(7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Tangency Portfolio is " + str((TP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_TP)
            return fig, output_str, TP

        elif max_risk < TP_stddev:
            output_str += "The Global Minimum Variance Portfolio's daily Expected Returns (logged first difference) are: " + str(GMVP_expectedreturn[0].round(7)) + '  \n  '
            output_str += "The daily Standard Deviation (of the logged first difference returns) of the Global Minimum Variance Portfolio is " + str(GMVP_stddev[0].round(7)) + '  \n  ' 
            output_str += "The Global Minimum Variance Portfolio's annualized Expected Returns (logged first difference) are: " + str((GMVP_expectedreturn[0] * 252).round(7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Global Minimum Variance Portfolio is" + str((GMVP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_GMVP)
            return fig, output_str, GMVP
        
    else:
        if risk_free_asset == True and use_TP == False:
            output_str += "The Optimal Portfolio with Risk Free Asset's daily Expected Returns (logged first difference) are: " + str(round(RFAP_expectedreturn[0], 7)) + '  \n  '
            output_str += "The daily Standard Deviation (of the logged first difference returns) of the Optimal Portfolio with Risk Free Asset is " + str(RFAP_stddev[0].round(7)) + '  \n  ' 
            output_str += "The Optimal Portfolio with Risk Free Asset's annualized Expected Returns (logged first difference) are: " + str(round((RFAP_expectedreturn[0] * 252), 7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Optimal Portfolio with Risk Free Asset is " + str((RFAP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_RFAP, risk_free_asset = True)
            return fig, output_str, RFAP
        
        elif use_TP == True:
            output_str += "WARNING: Expected returns input is higher than that of the tangency portfolio.  \n  "
            output_str += "Since it is impossible to achieve expected returns higher than the tangency portfolio that lies on the Security Market Line, Tangency Portfolio is selected.  \n  "
            output_str += "The Tangency Portfolio's daily Expected Returns (logged first difference) are: " + str(TP_expectedreturn[0].round(7)) + '  \n  '
            output_str += "The Standard Deviation (of the logged first difference returns) of the Tangency Portfolio is " + str(TP_stddev[0].round(7)) + '  \n  '
            output_str += "The Tangency Portfolio's annualized Expected Returns (logged first difference) are: " + str((TP_expectedreturn[0] * 252).round(7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Tangency Portfolio is " + str((TP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_TP)
            return fig, output_str, TP
        
        elif noRFAP_expectedreturn[0] < GMVP_expectedreturn:      
            output_str += "WARNING: Selected Optimal Portfolio is an Inefficient Portfolio.  \n  "
            output_str += "There exists a Portfolio with higher expected returns for a lower amount of expected risk. Global Minimum Variance Portfolio is selected instead.  \n  "
            output_str += "The Global Minimum Variance Portfolio's daily Expected Returns (logged first difference) are: " + str(GMVP_expectedreturn[0].round(7)) + '  \n  '
            output_str += "The daily Standard Deviation (of the logged first difference returns) of the Global Minimum Variance Portfolio is " + str(GMVP_stddev[0].round(7)) + '  \n  '
            output_str += "The Global Minimum Variance Portfolio's annualized Expected Returns (logged first difference) are: " + str((GMVP_expectedreturn[0] * 252).round(7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Global Minimum Variance Portfolio is " + str((GMVP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_GMVP)
            return fig, output_str, GMVP
        
        else:
            output_str += "The Optimal Portfolio without Risk Free Asset's daily Expected Returns (logged first difference) are: " + str(noRFAP_expectedreturn[0].round(7)) + '    \n    '
            output_str += "The daily Standard Deviation (of the logged first difference returns) of the Optimal Portfolio without Risk Free Asset is " + str(noRFAP_stddev[0].round(7)) + '    \n    '
            output_str += "The Optimal Portfolio without Risk Free Asset's annualized Expected Returns (logged first difference) are:" + str((noRFAP_expectedreturn[0] * 252).round(7)) + '  \n  '
            output_str += "The annualized Standard Deviation (of the logged first difference returns) of the Optimal Portfolio without Risk Free Asset is " + str((noRFAP_stddev[0] * np.sqrt(252)).round(7)) + '  \n  '
            output_str += Sharpe_Ratio(portfolio_tickers, start_date, adj_close, close, risk_free_rate, weights_noRFAP)
            return fig, output_str, noRFAP

# Example Test Cases - (no extra arguments, default Tagency Portfolio)
fig, output_str, noRFAP = Portfolio_Optimization(['SPY', 'TLT', 'EFA', 'TSLA', 'NIO', 'BABA', 'AMZN', 'BNGO', 'GOTU'])

if __name__ == '__main__':
    pass

# %%
